재활용이 가능한 컴포넌트들은 어떤것들이 존재 하는가?-> animation,collider
Transform의 소유자는? 하나의 게임오브젝트에 멀티 Transform을 허용하는가? 월드 Matrix계산은 언제?-> 렌더매니저의 렌더()에서 렌더러 컴포넌트의 Transform->GetWorldMatix()를 호출하면서 -> GetLocalMatrix가 호출되면서 정리
각 종류별 컴포넌트를 다루는 Manager or System의 역할은?-> 매니저와 시스템을 통합, '시스템' 토큰은 별도의 클래스 이름으로 사용됨
역할 구분이 모호한 RenderManager는 어떻게 분리되었나?-> RenderAPI라는 인터페이스를 도입해서 그래픽스 API의 컨텍스트 객체를 마련해두고 그림을 그리는 요청은 컨텍스트 객체가 처리하도록 분리
Scene의 역할은 어디까지 인가?-> GameObject의 컨테이너이다. 생성시킬 GameObject의 정보를 가지고 있고
  런타임에서 엔진의 요청에 의해 다른 씬으로 교체가 일어나거나
  자기자신이 파괴될 때 소유하고 있는 GameObject의 인스턴스를 전부 파괴해야하는 책임을 가지고 있다.(그것이 컨테이너니까 - 고이즈미 짤)
로딩된 리소스 재활용 방식은?
위임설계(델리게이트)를 적용한 부분과 방식은?-> 사용자 정의 컴포넌트 혹은 엔진 코어의 컴포넌트에서 서로 통신하기 위해 사용되었음
  또한 엔진 코어 부분에서도 윈도우 사이즈 변경에 대한 정보를 그래픽스 API에 넘겨주기 위해 사용됨
게임오브젝트 또는 컴포넌트의 주소 유효성 검증은 어떤 클래스에서 담당하는가?-> GameObject, Component의 베이스 클래스인 Object에서 정적 함수로 처리됨, Object를 상속받는 모든 클래스는 Object의 생성자에 의해
  자신의 Object부분의 정보를 Object클래스의 objectRegistry에 등록시켜 어디서든 추적가능한 상태로 만듬
입력은 어떻게 처리하는가?-> 기존의 매니저 개념을 사용함
게임오브젝트도 상속을 사용하였나?-> 앞서 말했듯이 Object를 상속했으며, Object엔 인스턴스의 유효성(댕글러 포인터 방지)검증에 필요한 멤버변수와 정적함수가 마련되어 있음
컨텐츠 구현은 어떤 클래스를 상속하거나 생성하여 작성하여야 하는가?->