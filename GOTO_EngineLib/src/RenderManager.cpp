#include "RenderManager.h"
#include "IRenderAPI.h"
#include "IWindow.h"
#include "Camera.h"
#include "Delegate.h"
#include "D2DRenderAPI.h"
#include "Renderer.h"
#include "algorithm"
#include "Matrix3x3.h"
#ifdef _DEBUG
#include <iostream>
#endif

using namespace GOTOEngine;

void RenderManager::StartUp(IWindow* window)
{
#ifdef _USE_DIRECT2D
	m_pRenderAPI = new D2DRenderAPI();
#endif

	if (!m_pRenderAPI->Initialize(window))
	{
		delete m_pRenderAPI;
		m_pRenderAPI = nullptr;
	}
	else
	{
		dynamic_cast<IWindow*>(window)->SetOnChangedWindowSize([this](int width, int height) {
			m_pRenderAPI->ChangeBufferSize(width, height);
#ifdef _DEBUG
			std::cout << width << "," << height << std::endl;
#endif 
			});
	}
}

void RenderManager::ShutDown()
{
	m_cameras.clear();

	if (m_pRenderAPI)
	{
		delete m_pRenderAPI;
		m_pRenderAPI = nullptr;
	}
}

void GOTOEngine::RenderManager::RegisterCamera(Camera* cam)
{
	m_cameras.push_back(cam);
	SetCamSortDirty();
}

void GOTOEngine::RenderManager::UnRegisterCamera(Camera* cam)
{
	m_cameras.erase(
		std::remove_if(m_cameras.begin(), m_cameras.end(),
			[cam](const auto& item) { return item == cam; }),
		m_cameras.end());

	SetCamSortDirty();
}

void GOTOEngine::RenderManager::RegisterRenderer(Renderer* renderer)
{
	m_renderers.push_back(renderer);
	SetRendererSortDirty();
}

void GOTOEngine::RenderManager::UnRegisterRenderer(Renderer* renderer)
{
	m_renderers.erase(
		std::remove_if(m_renderers.begin(), m_renderers.end(),
			[renderer](const auto& item) { return item == renderer; }),
		m_renderers.end());
	SetRendererSortDirty();
}

void GOTOEngine::RenderManager::SortCamera()
{
	std::sort(m_cameras.begin(), m_cameras.end(),
		[](Camera* a, Camera* b) {
			return a->GetDepth() < b->GetDepth();
		});
}

void GOTOEngine::RenderManager::SortRenderer()
{
	std::sort(m_renderers.begin(), m_renderers.end(),
		[](Renderer* a, Renderer* b) {
			return a->m_renderOrder < b->m_renderOrder;
		});
}

IRenderBitmap* GOTOEngine::RenderManager::CreateBitmap(std::wstring filePath)
{
	return m_pRenderAPI->CreateBitmap(filePath);
}

void RenderManager::SetVSyncInterval(int interval)
{
	if (m_pRenderAPI)
	{
		m_pRenderAPI->SetVSyncInterval(interval);
	}
}

void GOTOEngine::RenderManager::Render()
{
	//활성카메라, 비활성카메라 설정
	//CheckActiveCamera();
	//CheckActiveRenderer();
	//둘 중 하나라도 없는 경우 렌더 종료
	//if(m_activeCamera.size() == 0 || m_activeRenderer.size() == 0) { Clear(); SwapBuffer(); return; }

	if(m_needCamDepthSort)
		SortCamera();

	if (m_needRenderOrderSort)
		SortRenderer();

	m_pRenderAPI->Clear();

	//렌더링
	//멀티 카메라를 구현하려면 렌더타겟(백 버퍼)이 카메라마다 존재해야함
	//활성화된 카메라를 돌면서 Clear -> 렌더링해주고 최종 렌더타겟을 하나에 모아서 Composite(합치기)
	//그리고 그 렌더타겟을 스왑체인이나 메인버퍼로 올려주고 플립핑

	for (const auto& camera : m_cameras)
	{
		if (!camera->GetEnabled())
			continue;

		//카메라 행렬 구하기
		auto camRect = camera->GetRect();
		Matrix3x3 unityCoordMat = 
		    Matrix3x3::Translate(m_pRenderAPI->GetWindow().GetWidth() * (camRect.x + (camRect.width * 0.5f)) , 
				m_pRenderAPI->GetWindow().GetHeight() * (camRect.y + (camRect.height * 0.5f)))
			* Matrix3x3::Scale(1.0f, -1.0f) 
			* camera->GetMatrix();

		//Todo : 그리기 전에 카메라 영역 박스색칠 (렌더타겟이 없기 때문에 클리어 대신 씀)
		// -> 카메라 배경색 (solid color) 구현하기
		// -> 추가로 카메라 영역이 이미 다른 카메라영역에 의해 완벽히 가려지면 다음 카메라 렌더링으로 넘어가기
		// ---->> 앞서 그린 카메라 영역의 최대크기를 렌더링이 끝날 때 마다 갱신하고 다음 카메라 렌더링에서 비교하기
		//---코드
		
		for (const auto& renderer : m_renderers)
		{
			if (!renderer->GetEnabled()
				|| (renderer->GetRenderLayer() & camera->GetRenderLayer()) == 0)
				continue;

			//뷰포트 제한
			m_pRenderAPI->SetViewport(camRect);
			renderer->Render(unityCoordMat);
			m_pRenderAPI->ResetViewport();
		}
	}
	m_pRenderAPI->SwapBuffer();
}

const GOTOEngine::IWindow* GOTOEngine::RenderManager::GetWindow() const
{
	return &m_pRenderAPI->GetWindow();
}

